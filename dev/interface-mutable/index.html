<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mutable arithmetic Â· Arblib.jl</title><meta name="title" content="Mutable arithmetic Â· Arblib.jl"/><meta property="og:title" content="Mutable arithmetic Â· Arblib.jl"/><meta property="twitter:title" content="Mutable arithmetic Â· Arblib.jl"/><meta name="description" content="Documentation for Arblib.jl."/><meta property="og:description" content="Documentation for Arblib.jl."/><meta property="twitter:description" content="Documentation for Arblib.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Arblib.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Arblib.jl Documentation</a></li><li><span class="tocitem">Low level wrapper</span><ul><li><a class="tocitem" href="../wrapper-types/">Types</a></li><li><a class="tocitem" href="../wrapper-methods/">Methods</a></li><li><a class="tocitem" href="../wrapper-fpwrap/">Floating point wrapper</a></li></ul></li><li><span class="tocitem">High level interface</span><ul><li><a class="tocitem" href="../interface-types/">Types</a></li><li><a class="tocitem" href="../interface-ball/">Ball methods</a></li><li><a class="tocitem" href="../interface-integration/">Integration</a></li><li><a class="tocitem" href="../interface-series/">Series</a></li><li class="is-active"><a class="tocitem" href>Mutable arithmetic</a><ul class="internal"><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li><li><a class="tocitem" href="../precision/">Precision</a></li><li><a class="tocitem" href="../printing/">Printing</a></li></ul></li><li><a class="tocitem" href="../rigorous/">Rigorous numerics</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">High level interface</a></li><li class="is-active"><a href>Mutable arithmetic</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mutable arithmetic</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kalmarek/Arblib.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ï‚›</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/kalmarek/Arblib.jl/blob/master/docs/src/interface-mutable.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ï„</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Mutable-arithmetic"><a class="docs-heading-anchor" href="#Mutable-arithmetic">Mutable arithmetic</a><a id="Mutable-arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#Mutable-arithmetic" title="Permalink"></a></h1><p>The high level interface can be combined with the low level wrapper to allow for efficient computations using mutable arithmetic. Making use of mutable arithmetic can in some cases have a significant impact on the performance of the code, in particular for multithreaded code (where avoiding to run the GC is generally more important) and code running many iterations of simple computations.</p><p>In the future it would be nice to have an interface to <a href="https://github.com/jump-dev/MutableArithmetics.jl">MutableArithmetics.jl</a>, see <a href="https://github.com/kalmarek/Arblib.jl/issues/118">#118</a>.</p><p>The following methods are useful for mutating part of a value</p><article><details class="docstring" open="true"><summary id="Arblib.radref"><a class="docstring-binding" href="#Arblib.radref"><code>Arblib.radref</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">radref(x::ArbLike, prec = precision(x))</code></pre><p>Return a <code>MagRef</code> referencing the radius of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/Arblib.jl/blob/f02c51d2bc6f075d2ad252c26e0a94c2b73f1a84/src/ref.jl#L86-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Arblib.midref"><a class="docstring-binding" href="#Arblib.midref"><code>Arblib.midref</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">midref(x::ArbLike, prec = precision(x))</code></pre><p>Return an <code>ArfRef</code> referencing the midpoint of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/Arblib.jl/blob/f02c51d2bc6f075d2ad252c26e0a94c2b73f1a84/src/ref.jl#L76-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Arblib.realref"><a class="docstring-binding" href="#Arblib.realref"><code>Arblib.realref</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">realref(z::AcfLike, prec = precision(z))</code></pre><p>Return an <code>ArfRef</code> referencing the real part of <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/Arblib.jl/blob/f02c51d2bc6f075d2ad252c26e0a94c2b73f1a84/src/ref.jl#L56-L60">source</a></section><section><div><pre><code class="language-julia hljs">realref(z::AcbLike, prec = precision(z))</code></pre><p>Return an <code>ArbRef</code> referencing the real part of <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/Arblib.jl/blob/f02c51d2bc6f075d2ad252c26e0a94c2b73f1a84/src/ref.jl#L96-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Arblib.imagref"><a class="docstring-binding" href="#Arblib.imagref"><code>Arblib.imagref</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">imagref(z::AcfLike, prec = precision(z))</code></pre><p>Return an <code>ArfRef</code> referencing the imaginary part of <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/Arblib.jl/blob/f02c51d2bc6f075d2ad252c26e0a94c2b73f1a84/src/ref.jl#L66-L70">source</a></section><section><div><pre><code class="language-julia hljs">imagref(z::AcbLike, prec = precision(z))</code></pre><p>Return an <code>ArbRef</code> referencing the imaginary part of <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/Arblib.jl/blob/f02c51d2bc6f075d2ad252c26e0a94c2b73f1a84/src/ref.jl#L106-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Arblib.ref"><a class="docstring-binding" href="#Arblib.ref"><code>Arblib.ref</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ref(v::Union{ArbVectorOrRef,AcbVectorOrRef}, i)</code></pre><p>Similar to <code>v[i]</code> but instead of an <code>Arb</code> or <code>Acb</code> returns an <code>ArbRef</code> or <code>AcbRef</code> which still shares the memory with the <code>i</code>-th entry of <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/Arblib.jl/blob/f02c51d2bc6f075d2ad252c26e0a94c2b73f1a84/src/vector.jl#L26-L32">source</a></section><section><div><pre><code class="language-julia hljs">ref(A::Union{ArbMatrixOrRef,AcbMatrixOrRef}, i, j)</code></pre><p>Similar to <code>A[i,j]</code> but instead of an <code>Arb</code> or <code>Acb</code> returns an <code>ArbRef</code> or <code>AcbRef</code> which still shares the memory with the <code>(i,j)</code>-th entry of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/Arblib.jl/blob/f02c51d2bc6f075d2ad252c26e0a94c2b73f1a84/src/matrix.jl#L35-L41">source</a></section><section><div><pre><code class="language-julia hljs">ref(p::Union{ArbPoly,ArbSeries,AcbPoly,AcbSeries}, i)</code></pre><p>Similar to <code>p[i]</code> but instead of an <code>Arb</code> or <code>Acb</code> returns an <code>ArbRef</code> or <code>AcbRef</code> which shares the memory with the <code>i</code>-th coefficient of <code>p</code>.</p><div class="admonition is-info" id="Note-31f083d92280938d"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-31f083d92280938d" title="Permalink"></a></header><div class="admonition-body"><p>Using <code>ref</code> for reading coefficients is always safe, but if the coefficient is mutated then care has to be taken. See the comment further down for how to handle mutation.</p></div></div><p>It only allows accessing coefficients that are allocated. For <code>ArbPoly</code> and <code>AcbPoly</code> this is typically all coefficients up to the degree of the polynomial, but can be higher if for example <code>Arblib.fit_length!</code> is used. For <code>ArbSeries</code> and <code>AcbSeries</code> all coefficients up to the degree of the series are guaranteed to be allocated, even if the underlying polynomial has a lower degree.</p><p>If the coefficient is mutated in a way that the degree of the polynomial changes then one needs to also update the internally stored length of the polynomial.</p><ul><li>If the new degree is the same or lower this can be achieved with<pre><code class="nohighlight hljs">Arblib.normalise!(p)</code></pre></li><li>If the new degree is higher you need to manually set the length. This can be achieved with<pre><code class="nohighlight hljs">Arblib.set_length!(p, len)
Arblib.normalise!(p)</code></pre>where <code>len</code> is one higher than (an upper bound of) the new degree.</li></ul><p>See the extended help for more details.</p><p><strong>Extended help</strong></p><p>Here is an example were the leading coefficient is mutated so that the degree is lowered.</p><pre><code class="language-julia-repl hljs">julia&gt; p = ArbPoly([1, 2], prec = 64) # Polynomial of degree 1
1.0 + 2.0â‹…x

julia&gt; Arblib.zero!(Arblib.ref(p, 1)) # Set leading coefficient to 0
0

julia&gt; Arblib.degree(p) # The degree is still reported as 1
1

julia&gt; length(p) # And the length as 2
2

julia&gt; p # Printing gives weird results
1.0 +

julia&gt; Arblib.normalise!(p) # Normalising the polynomial updates the degree
1.0

julia&gt; Arblib.degree(p) # This is now correct
0

julia&gt; p # And so is printing
1.0</code></pre><p>Here is an example when a coefficient above the degree is mutated.</p><pre><code class="language-julia-repl hljs">julia&gt; q = ArbSeries([1, 2, 0], prec = 64) # Series of degree 3 with leading coefficient zero
1.0 + 2.0â‹…x + ğ’ª(x^3)

julia&gt; Arblib.one!(Arblib.ref(q, 2)) # Set the leading coefficient to 1
1.0

julia&gt; q # The leading coefficient is not picked up
1.0 + 2.0â‹…x + ğ’ª(x^3)

julia&gt; Arblib.degree(q.poly) # The degree of the underlying polynomial is still 1
1

julia&gt; Arblib.set_length!(q, 3) # After explicitly setting the length to 3 it is ok
1.0 + 2.0â‹…x + 1.0â‹…x^2 + ğ’ª(x^3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/Arblib.jl/blob/f02c51d2bc6f075d2ad252c26e0a94c2b73f1a84/src/poly.jl#L79-L161">source</a></section></details></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>Compare computing <span>$\sqrt{x^2 + y^2}$</span> using mutable arithmetic with the default.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Arblib, BenchmarkTools</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = Arb(1 // 3)</code><code class="nohighlight hljs ansi" style="display:block;">[0.33333333333333333333333333333333333333333333333333333333333333333333333333333 +/- 4.78e-78]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y = Arb(1 // 5)</code><code class="nohighlight hljs ansi" style="display:block;">[0.20000000000000000000000000000000000000000000000000000000000000000000000000000 +/- 3.89e-78]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; res = zero(x)</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(x, y) = sqrt(x^2 + y^2)</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f!(res, x, y) = begin
           Arblib.sqr!(res, x)
           Arblib.fma!(res, res, y, y)
           return Arblib.sqrt!(res, res)
       end</code><code class="nohighlight hljs ansi" style="display:block;">f! (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @benchmark f($x, $y) samples=10000 evals=500</code><code class="nohighlight hljs ansi" style="display:block;">BenchmarkTools.Trial: 10000 samples with 500 evaluations per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> â€¦ <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">483.304 ns</span></span> â€¦ <span class="sgr35">200.995 Î¼s</span>  <span class="sgr90">â”Š</span> GC <span class="sgr90">(</span>min â€¦ max<span class="sgr90">): </span> 0.00% â€¦ 36.30%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">516.566 ns               </span></span><span class="sgr90">â”Š</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span> 0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> Â± <span class="sgr32">Ïƒ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">869.246 ns</span></span> Â± <span class="sgr32">  6.822 Î¼s</span>  <span class="sgr90">â”Š</span> GC <span class="sgr90">(</span>mean Â± Ïƒ<span class="sgr90">):  </span>14.07% Â±  1.86%

  â–‚â–ƒâ–‚â–†â–ˆ<span class="sgr34">â–ˆ</span>â–†â–†â–†â–ƒâ–            â–                                     <span class="sgr32"> </span>â–‚
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ<span class="sgr34">â–ˆ</span>â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–‡â–‡â–‡â–†â–‡â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–†â–†â–…â–…â–„â–…â–ƒâ–…â–ƒâ–â–„â–„â–â–â–ƒâ–…â–ƒâ–â–„â–â–„â–„â–ƒâ–â–â–ƒâ–ƒâ–ƒâ–„â–…â–†â–…â–„â–†<span class="sgr32"> </span>â–ˆ
  483 ns<span class="sgr90">        Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>        872 ns <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">416 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">8</span>.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @benchmark f!($res, $x, $y) samples=10000 evals=500</code><code class="nohighlight hljs ansi" style="display:block;">BenchmarkTools.Trial: 10000 samples with 500 evaluations per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> â€¦ <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">294.792 ns</span></span> â€¦ <span class="sgr35">621.864 ns</span>  <span class="sgr90">â”Š</span> GC <span class="sgr90">(</span>min â€¦ max<span class="sgr90">): </span>0.00% â€¦ 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">308.796 ns               </span></span><span class="sgr90">â”Š</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> Â± <span class="sgr32">Ïƒ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">309.644 ns</span></span> Â± <span class="sgr32"> 11.020 ns</span>  <span class="sgr90">â”Š</span> GC <span class="sgr90">(</span>mean Â± Ïƒ<span class="sgr90">):  </span>0.00% Â± 0.00%

                          â–ˆ<span class="sgr34">â–‡</span><span class="sgr32"> </span>                                   
  â–â–â–â–â–â–â–â–‚â–‚â–…â–„â–‚â–ƒâ–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–ƒâ–†â–…â–ˆ<span class="sgr34">â–ˆ</span><span class="sgr32">â–ƒ</span>â–ƒâ–‚â–‚â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–‚â–â–‚â–‚â–ƒâ–‚â–‚â–â–â–â–â–â–â–â– â–‚
  295 ns<span class="sgr90">           Histogram: frequency by time</span>          329 ns <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">0 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">0</span>.</code></pre><div class="admonition is-warning" id="Aliasing-between-input-and-output-e575be9783ebd4e9"><header class="admonition-header">Aliasing between input and output<a class="admonition-anchor" href="#Aliasing-between-input-and-output-e575be9783ebd4e9" title="Permalink"></a></header><div class="admonition-body"><p>This implementation of the function <code>f!</code> doesn&#39;t handle aliasing between <code>res</code> and <code>x</code>. Most cases of aliasing between two variables can be checked for with <code>===</code> (so <code>res === x</code> in this case). Using <code>===</code> does however not catch all possible cases of aliasing, for example it would not catch the aliasing between <code>Arblib.realref(z)</code> and <code>Arblib.realref(z, prec = 2precision(z))</code>.</p></div></div><p>Set the radius of the real part of an <code>Acb</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Arblib</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; z = Acb(1, 2)</code><code class="nohighlight hljs ansi" style="display:block;">1.0 + 2.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Arblib.set!(Arblib.radref(Arblib.realref(z)), 1e-10)</code><code class="nohighlight hljs ansi" style="display:block;">1.0e-10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; z</code><code class="nohighlight hljs ansi" style="display:block;">[1.000000000 +/- 1.01e-10] + 2.0im</code></pre><p>Compare a naive implementation of polynomial evaluation using mutable arithmetic with one not using using it.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Arblib, BenchmarkTools</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = ArbPoly(1:10)</code><code class="nohighlight hljs ansi" style="display:block;">1.0 + 2.0â‹…x + 3.0â‹…x^2 + 4.0â‹…x^3 + 5.0â‹…x^4 + 6.0â‹…x^5 + 7.0â‹…x^6 + 8.0â‹…x^7 + 9.0â‹…x^8 + 10.0â‹…x^9</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = Arb(1 // 3)</code><code class="nohighlight hljs ansi" style="display:block;">[0.33333333333333333333333333333333333333333333333333333333333333333333333333333 +/- 4.78e-78]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; res = zero(x)</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function eval(p, x)
           res = zero(x)
           xi = one(x)
           for i in 0:Arblib.degree(p)
               res += p[i] * xi
               xi *= x
           end
           return res
       end</code><code class="nohighlight hljs ansi" style="display:block;">eval (generic function with 2 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function eval!(res, p, x)
           Arblib.zero!(res)
           xi = one(x)
           for i in 0:Arblib.degree(p)
               Arblib.addmul!(res, Arblib.ref(p, i), xi)
               Arblib.mul!(xi, xi, x)
           end
           return res
       end</code><code class="nohighlight hljs ansi" style="display:block;">eval! (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @benchmark eval($p, $x) samples = 10000 evals = 30</code><code class="nohighlight hljs ansi" style="display:block;">BenchmarkTools.Trial: 10000 samples with 30 evaluations per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> â€¦ <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">2.532 Î¼s</span></span> â€¦ <span class="sgr35">  5.079 ms</span>  <span class="sgr90">â”Š</span> GC <span class="sgr90">(</span>min â€¦ max<span class="sgr90">): </span> 0.00% â€¦ 39.40%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">2.665 Î¼s               </span></span><span class="sgr90">â”Š</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span> 0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> Â± <span class="sgr32">Ïƒ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">5.903 Î¼s</span></span> Â± <span class="sgr32">111.691 Î¼s</span>  <span class="sgr90">â”Š</span> GC <span class="sgr90">(</span>mean Â± Ïƒ<span class="sgr90">):  </span>19.33% Â±  1.04%

  â–…â–ˆ<span class="sgr34">â–‡</span>â–ƒâ–â–â–ƒâ–„â–‚â–â–â–ƒâ–‚â–‚â–    â–‚â–„â–…â–…â–„  â–â–â–                            <span class="sgr32"> </span>  â–‚
  â–ˆâ–ˆ<span class="sgr34">â–ˆ</span>â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–†â–‡â–‡â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–†â–‡â–ˆâ–…â–â–â–„â–„â–„â–„â–„â–â–ƒâ–ƒâ–„â–â–ƒâ–â–„â–â–„â–ƒâ–â–ƒâ–ƒâ–ƒâ–<span class="sgr32">â–ƒ</span>â–ƒ â–ˆ
  2.53 Î¼s<span class="sgr90">      Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>      6.01 Î¼s <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">3.72 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">70</span>.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @benchmark eval!($res, $p, $x) samples = 10000 evals = 30</code><code class="nohighlight hljs ansi" style="display:block;">BenchmarkTools.Trial: 10000 samples with 30 evaluations per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> â€¦ <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">963.467 ns</span></span> â€¦ <span class="sgr35"> 11.997 Î¼s</span>  <span class="sgr90">â”Š</span> GC <span class="sgr90">(</span>min â€¦ max<span class="sgr90">): </span>0.00% â€¦ 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">974.500 ns               </span></span><span class="sgr90">â”Š</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> Â± <span class="sgr32">Ïƒ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">990.025 ns</span></span> Â± <span class="sgr32">128.312 ns</span>  <span class="sgr90">â”Š</span> GC <span class="sgr90">(</span>mean Â± Ïƒ<span class="sgr90">):  </span>0.00% Â± 0.00%

  â–„â–ˆ<span class="sgr34">â–‡</span>â–†â–†â–„<span class="sgr32">â–ƒ</span>â–ƒâ–‚â–â–                                                   â–‚
  â–ˆâ–ˆ<span class="sgr34">â–ˆ</span>â–ˆâ–ˆâ–ˆ<span class="sgr32">â–ˆ</span>â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–†â–†â–‡â–‡â–†â–†â–†â–…â–…â–„â–…â–…â–„â–â–ƒâ–â–ƒâ–„â–ƒâ–ƒâ–â–ƒâ–â–â–â–ƒâ–ƒâ–â–ƒâ–â–â–ƒâ–â–â–â–â–â–ƒâ–ƒâ–„â–†â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡ â–ˆ
  963 ns<span class="sgr90">        Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>       1.26 Î¼s <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">144 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">3</span>.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @benchmark $p($x) samples = 10000 evals = 30 # Arb implementation for reference</code><code class="nohighlight hljs ansi" style="display:block;">BenchmarkTools.Trial: 10000 samples with 30 evaluations per sample.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> â€¦ <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">779.133 ns</span></span> â€¦ <span class="sgr35"> 12.900 Î¼s</span>  <span class="sgr90">â”Š</span> GC <span class="sgr90">(</span>min â€¦ max<span class="sgr90">): </span>0.00% â€¦ 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">795.500 ns               </span></span><span class="sgr90">â”Š</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> Â± <span class="sgr32">Ïƒ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">807.776 ns</span></span> Â± <span class="sgr32">136.682 ns</span>  <span class="sgr90">â”Š</span> GC <span class="sgr90">(</span>mean Â± Ïƒ<span class="sgr90">):  </span>0.00% Â± 0.00%

  â–„â–‡â–ˆ<span class="sgr34">â–ˆ</span>â–‡â–†<span class="sgr32">â–…</span>â–ƒâ–‚â–‚â–                                               â–   â–‚
  â–ˆâ–ˆâ–ˆ<span class="sgr34">â–ˆ</span>â–ˆâ–ˆ<span class="sgr32">â–ˆ</span>â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–‡â–…â–†â–…â–…â–…â–„â–…â–…â–„â–â–„â–ƒâ–ƒâ–â–â–â–ƒâ–ƒâ–â–ƒâ–â–â–â–â–„â–ƒâ–ƒâ–â–â–â–â–ƒâ–â–â–â–â–â–„â–†â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆ
  779 ns<span class="sgr90">        Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>       1.08 Î¼s <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">144 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">3</span>.</code></pre><h3 id="Mutable-arithmetic-handling-both-Arb/Acb-and-ArbSeries/AcbSeries"><a class="docs-heading-anchor" href="#Mutable-arithmetic-handling-both-Arb/Acb-and-ArbSeries/AcbSeries">Mutable arithmetic handling both <code>Arb/Acb</code> and <code>ArbSeries/AcbSeries</code></a><a id="Mutable-arithmetic-handling-both-Arb/Acb-and-ArbSeries/AcbSeries-1"></a><a class="docs-heading-anchor-permalink" href="#Mutable-arithmetic-handling-both-Arb/Acb-and-ArbSeries/AcbSeries" title="Permalink"></a></h3><p>Since <code>Arblib.jl</code> version <code>1.3.0</code> adjustments have been made to the low level wrapper to make it easier to write code using mutable arithmetic that can handle both the scalar types <code>Arb</code> and <code>Acb</code> as well as the series types <code>ArbSeries</code> and <code>AcbSeries</code>. For example the following implementation of <code>sin(atan(x) / x)</code> can support all of these types.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Arblib</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f!(res, x)
           Arblib.atan!(res, x)
           Arblib.div!(res, res, x)
           Arblib.sin!(res, res)
           return res
       end</code><code class="nohighlight hljs ansi" style="display:block;">f! (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f!(Arb(prec = 53), Arb(2))</code><code class="nohighlight hljs ansi" style="display:block;">[0.525731112119133 +/- 6.90e-16]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f!(Acb(prec = 53), Acb(2, 3))</code><code class="nohighlight hljs ansi" style="display:block;">[0.277808890086608 +/- 8.76e-16] + [-0.283570391073164 +/- 7.96e-16]im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f!(ArbSeries(degree = 2, prec = 53), ArbSeries((2, 1)))</code><code class="nohighlight hljs ansi" style="display:block;">[0.525731112119133 +/- 6.90e-16] + [-0.150384157104163 +/- 2.78e-16]â‹…x + [0.032950523196531 +/- 3.27e-16]â‹…x^2 + ğ’ª(x^3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f!(AcbSeries(degree = 2, prec = 53), AcbSeries((2 + 3im, 1)))</code><code class="nohighlight hljs ansi" style="display:block;">([0.277808890086608 +/- 8.76e-16] + [-0.283570391073164 +/- 7.96e-16]im) + ([-0.003614644237407 +/- 6.26e-16] + [0.101930812170967 +/- 5.42e-16]im)â‹…x + ([-0.016354294747851 +/- 5.15e-16] + [-0.021459140853368 +/- 3.66e-16]im)â‹…x^2 + ğ’ª(x^3)</code></pre><p>To make this possible there is special handling of the series functions in Arb, see <a href="../wrapper-methods/#Series-methods">Series methods</a> for more details.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface-series/">Â« Series</a><a class="docs-footer-nextpage" href="../precision/">Precision Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 17 January 2026 01:43">Saturday 17 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
