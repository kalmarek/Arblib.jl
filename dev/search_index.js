var documenterSearchIndex = {"docs":
[{"location":"interface-series/#Series","page":"Series","title":"Series","text":"","category":"section"},{"location":"interface-series/","page":"Series","title":"Series","text":"Taylor series arithmetic allows for the computation of truncated Taylor series of functions and is a form of higher order automatic differentiation. See e.g. TaylorSeries.jl and TaylorDiff.jl for implementations of Taylor series in Julia.","category":"page"},{"location":"interface-series/","page":"Series","title":"Series","text":"The Arb library has good support for computing with polynomials as Taylor expansions. The types ArbSeries and AcbSeries are intended to make this easy to use from Julia. They are given by an ArbPoly/AcbPoly together with the length of the expansion.","category":"page"},{"location":"interface-series/#Example","page":"Series","title":"Example","text":"","category":"section"},{"location":"interface-series/","page":"Series","title":"Series","text":"using Arblib\n\nx0 = Arb(1 // 3, prec = 64)\nx = ArbSeries((x0, 1), degree = 5)\n\nsin(x)\n\nsin(x)^2 + cos(x)^2","category":"page"},{"location":"wrapper-fpwrap/#Floating-point-wrapper","page":"Floating point wrapper","title":"Floating point wrapper","text":"","category":"section"},{"location":"wrapper-fpwrap/","page":"Floating point wrapper","title":"Floating point wrapper","text":"The functions in the arb_fpwrap module of Arb are handled different from other functions. The methods for them are generated using","category":"page"},{"location":"wrapper-fpwrap/","page":"Floating point wrapper","title":"Floating point wrapper","text":"Arblib.ArbCall.@arbfpwrapcall_str\nArblib.ArbCall.ArbFPWrapFunction\nArblib.ArbCall.jlcode(af::Arblib.ArbCall.ArbFPWrapFunction)","category":"page"},{"location":"wrapper-fpwrap/#Arblib.ArbCall.@arbfpwrapcall_str","page":"Floating point wrapper","title":"Arblib.ArbCall.@arbfpwrapcall_str","text":"@arbfpwrapcall_str str\n\nParse a string as an Arblib.ArbCall.ArbFPWrapFunction, generate the code for a corresponding method with Arblib.ArbCall.jlcode and evaluate the code.\n\nFor example\n\narbfpwrapcall\"int arb_fpwrap_double_exp(double * res, double x, int flags)\"\n\ndefines the method\n\nfpwrap_exp(\n    x::Union{Float16, Float32, Float64};\n    error_on_failure::Bool = Arblib.ArbCall.fpwrap_error_on_failure_default(),\n    correct_rounding::Bool = false, work_limit::Integer = 8,\n)\n\n\n\n\n\n","category":"macro"},{"location":"wrapper-fpwrap/#Arblib.ArbCall.ArbFPWrapFunction","page":"Floating point wrapper","title":"Arblib.ArbCall.ArbFPWrapFunction","text":"ArbFPWrapFunction{T}(fname, args)\nArbFPWrapFunction(str)\n\nStruct representing an Arb function from the arb_fpwrap.h module.\n\n\n\n\n\n","category":"type"},{"location":"wrapper-fpwrap/#Arblib.ArbCall.jlcode-Tuple{Arblib.ArbCall.ArbFPWrapFunction}","page":"Floating point wrapper","title":"Arblib.ArbCall.jlcode","text":"jlcode(af::ArbFPWrapFunction, jl_fname = jlfname(af))\n\nGenerate the Julia code for calling a function from the fpwrap module of Arb from Julia.\n\n\n\n\n\n","category":"method"},{"location":"wrapper-fpwrap/","page":"Floating point wrapper","title":"Floating point wrapper","text":"The name for the generated method is given by removing the arb prefix and the double or cdouble in the middle of the name.","category":"page"},{"location":"wrapper-fpwrap/","page":"Floating point wrapper","title":"Floating point wrapper","text":"The flag argument that the C functions take are split into several keyword arguments in Julia. For the double type this is correct_rounding::Bool = false and work_limit::Integer = 8. For the cdouble type it also includes accurate_parts::Bool = false. The default values correspond to setting the flag to 0 in C.","category":"page"},{"location":"wrapper-fpwrap/","page":"Floating point wrapper","title":"Floating point wrapper","text":"The C functions return an int flag indicating the status. If the return flag is FPWRAP_SUCCESS the computed value is returned. If the return flag is FPWRAP_UNABLE it throws an error if the keyword argument error_on_failure is true and returns NaN otherwise. The default value for error_on_failure is handled by the following two methods","category":"page"},{"location":"wrapper-fpwrap/","page":"Floating point wrapper","title":"Floating point wrapper","text":"Arblib.ArbCall.fpwrap_error_on_failure_default\nArblib.ArbCall.fpwrap_error_on_failure_default_set","category":"page"},{"location":"wrapper-fpwrap/#Arblib.ArbCall.fpwrap_error_on_failure_default","page":"Floating point wrapper","title":"Arblib.ArbCall.fpwrap_error_on_failure_default","text":"fpwrap_error_on_failure_default()\n\nFunction giving the default value for the argument error_on_failure. See also fpwrap_error_on_failure_default_set.\n\n\n\n\n\n","category":"function"},{"location":"wrapper-fpwrap/#Arblib.ArbCall.fpwrap_error_on_failure_default_set","page":"Floating point wrapper","title":"Arblib.ArbCall.fpwrap_error_on_failure_default_set","text":"fpwrap_error_on_failure_default_set(value::Bool)\n\nSet the default value for the argument error_on_failure for fpwrap methods. See also fpwrap_error_on_failure_default.\n\n\n\n\n\n","category":"function"},{"location":"rigorous/#Rigorous-numerics","page":"Rigorous numerics","title":"Rigorous numerics","text":"","category":"section"},{"location":"rigorous/","page":"Rigorous numerics","title":"Rigorous numerics","text":"Arb is made for rigorous numerics and any functions which do not produce rigorous results are clearly marked as such. This is not the case with Julia in general and you therefore have to be careful when interacting with the ecosystem if you want your results to be completely rigorous. Below we discuss some things to be extra careful with.","category":"page"},{"location":"rigorous/#Implicit-promotion","page":"Rigorous numerics","title":"Implicit promotion","text":"","category":"section"},{"location":"rigorous/","page":"Rigorous numerics","title":"Rigorous numerics","text":"Julia automatically promotes types in many cases and in particular you have to watch out for temporary non-rigorous values. For example 2(π * Arb(1 // 3)) is okay, but not 2π * Arb(1 // 3)","category":"page"},{"location":"rigorous/","page":"Rigorous numerics","title":"Rigorous numerics","text":"x = 2(π * Arb(1 // 3))\ny = 2π * Arb(1 // 3)\nArblib.overlaps(x, y)","category":"page"},{"location":"rigorous/#Non-rigorous-algorithms","page":"Rigorous numerics","title":"Non-rigorous algorithms","text":"","category":"section"},{"location":"rigorous/","page":"Rigorous numerics","title":"Rigorous numerics","text":"Standard numerical algorithms typically return (hopefully good) approximations. These algorithms can then not directly be used in rigorous numerical computations unless the error can be bounded.","category":"page"},{"location":"rigorous/","page":"Rigorous numerics","title":"Rigorous numerics","text":"For example Julias built in methods for solving linear systems doesn't produce rigorous results. Instead you would have to use the solves provided by Arb, such as Arblib.solve!.","category":"page"},{"location":"rigorous/","page":"Rigorous numerics","title":"Rigorous numerics","text":"Other examples would include integration and solving of differential equations.","category":"page"},{"location":"rigorous/#Implementation-details","page":"Rigorous numerics","title":"Implementation details","text":"","category":"section"},{"location":"rigorous/","page":"Rigorous numerics","title":"Rigorous numerics","text":"In some cases the implementation in Julia implicitly makes certain assumptions to improve performance and this can lead to issues.","category":"page"},{"location":"rigorous/","page":"Rigorous numerics","title":"Rigorous numerics","text":"For example, prior to Julia version 1.8 the minimum and maximum methods in Julia checked for NaN results (on which is short fuses) using x == x, which works for most numerical types but not for Arb (x == x is only true if the radius is zero). See https://github.com/JuliaLang/julia/issues/36287 and in particular https://github.com/JuliaLang/julia/issues/45932 for more details. Since Julia version 1.8 the minimum and maximum methods work correctly for Arb, for earlier versions of Julia it only works correctly in some cases.","category":"page"},{"location":"rigorous/","page":"Rigorous numerics","title":"Rigorous numerics","text":"These types of problems are the hardest to find since they are not clear from the documentation but you have to read the implementation, @which and @less are your friends in these cases.","category":"page"},{"location":"interface-ball/#Ball-methods","page":"Ball methods","title":"Ball methods","text":"","category":"section"},{"location":"interface-ball/","page":"Ball methods","title":"Ball methods","text":"The following methods are useful for explicitly dealing with the ball representation of Arb and related values.","category":"page"},{"location":"interface-ball/#Construction","page":"Ball methods","title":"Construction","text":"","category":"section"},{"location":"interface-ball/","page":"Ball methods","title":"Ball methods","text":"For constructing balls the methods below are useful. Note that there is no setinterval method, this is instead accomplished with Arb((a, b)) for constructing a ball containing the interval a b.","category":"page"},{"location":"interface-ball/","page":"Ball methods","title":"Ball methods","text":"setball\nadd_error","category":"page"},{"location":"interface-ball/#Arblib.setball","page":"Ball methods","title":"Arblib.setball","text":"setball(::Type{Arb}, m, r; prec = _precision(m))\n\nReturns an Arb with the midpoint and radius set to m and r respectively.\n\nNote that the m is converted to an Arf and therefore rounded. So for example setball(1 // 3, 0) will not contain 1  3.\n\nSee also getball and add_error.\n\n\n\n\n\n","category":"function"},{"location":"interface-ball/#Arblib.add_error","page":"Ball methods","title":"Arblib.add_error","text":"add_error(x, err)\n\nReturns a copy of x with the absolute value of err added to the radius.\n\nFor complex x it adds the error to both the real and imaginary parts. For matrices it adds it elementwise.\n\nSee also setball.\n\n\n\n\n\n","category":"function"},{"location":"interface-ball/#Destruction","page":"Ball methods","title":"Destruction","text":"","category":"section"},{"location":"interface-ball/","page":"Ball methods","title":"Ball methods","text":"For extracting information about the ball representation the following methods are useful.","category":"page"},{"location":"interface-ball/","page":"Ball methods","title":"Ball methods","text":"radius\nmidpoint\nlbound\nubound\nabs_lbound\nabs_ubound\ngetinterval\ngetball","category":"page"},{"location":"interface-ball/#Arblib.radius","page":"Ball methods","title":"Arblib.radius","text":"radius([T, ] x::ArbOrRef)\n\nReturns the radius of x as a Mag. If T is given convert to this type, supports Mag, Arf, Arb and Float64.\n\n\n\n\n\n","category":"function"},{"location":"interface-ball/#Arblib.midpoint","page":"Ball methods","title":"Arblib.midpoint","text":"midpoint([T, ] x::ArbOrRef)\n\nReturns the midpoint of x as an Arf. If T is given convert to this type, supports Arf and Arb.\n\n\n\n\n\nmidpoint([T, ] z::AcbOrRef)\n\nReturns the midpoint of z as a Complex{Arf}. If T is given and equal to Arf or Arb, convert to Complex{T}. If T is Acb then convert to that.\n\n\n\n\n\n","category":"function"},{"location":"interface-ball/#Arblib.lbound","page":"Ball methods","title":"Arblib.lbound","text":"lbound([T, ] x::ArbOrRef)\n\nReturns a lower bound of x as an Arf. If T is given convert to this type, supports Arf and Arb.\n\nIf x contains NaN it returns NaN.\n\n\n\n\n\n","category":"function"},{"location":"interface-ball/#Arblib.ubound","page":"Ball methods","title":"Arblib.ubound","text":"ubound([T, ] x::ArbOrRef)\n\nReturns an upper bound of x as an Arf. If T is given convert to this type, supports Arf and Arb.\n\nIf x contains NaN it returns NaN.\n\n\n\n\n\n","category":"function"},{"location":"interface-ball/#Arblib.abs_lbound","page":"Ball methods","title":"Arblib.abs_lbound","text":"abs_lbound([T, ] x::Union{ArbOrRef,AcbOrRef})\n\nReturns a lower bound of abs(x) as an Arf. If T is given convert to this type, supports Arf and Arb.\n\nIf x contains NaN it returns NaN.\n\n\n\n\n\n","category":"function"},{"location":"interface-ball/#Arblib.abs_ubound","page":"Ball methods","title":"Arblib.abs_ubound","text":"abs_ubound([T, ] x::Union{ArbOrRef,AcbOrRef})\n\nReturns an upper bound of abs(x) as an Arf. If T is given convert to this type, supports Arf and Arb.\n\nIf x contains NaN it returns NaN.\n\n\n\n\n\n","category":"function"},{"location":"interface-ball/#Arblib.getinterval","page":"Ball methods","title":"Arblib.getinterval","text":"getinterval([T, ] x::ArbOrRef)\n\nReturns a tuple (l, u) representing an interval [l, u] enclosing the ball x, both of them are of type Arf. If T is given convert to this type, supports Arf, BigFloat and Arb.\n\nIf x contains NaN both l and u will be NaN.\n\nSee also getball.\n\n\n\n\n\n","category":"function"},{"location":"interface-ball/#Arblib.getball","page":"Ball methods","title":"Arblib.getball","text":"getball([T, ] x::ArbOrRef)\n\nReturns a tuple (m::Arf, r::Mag) where m is the midpoint of the ball and r is the radius. If T is given convert both m and r to this type, supports Arf and Arb.\n\nSee also setball and getinterval.\n\n\n\n\n\n","category":"function"},{"location":"interface-ball/#Union-and-intersection","page":"Ball methods","title":"Union and intersection","text":"","category":"section"},{"location":"interface-ball/","page":"Ball methods","title":"Ball methods","text":"The methods Arblib.union and Arblib.intersection compute the union and intersection of balls. Note that these methods are not exported and different from Base.union and Base.intersect.","category":"page"},{"location":"interface-ball/","page":"Ball methods","title":"Ball methods","text":"Arblib.union\nArblib.intersection","category":"page"},{"location":"interface-ball/#Arblib.union","page":"Ball methods","title":"Arblib.union","text":"union(x::ArbOrRef, y::ArbOrRef)\nunion(x::AcbOrRef, y::AcbOrRef)\nunion(x::T, y::T) where {T<:Union{ArbPoly,AcbPoly,ArbSeries,AcbSeries}}\nunion(x, y, z...)\n\nReturns a ball containing the union of x and y. For polynomials and series the union is taken coefficient-wise.\n\nunion(x, y, z...) returns a ball containing the union of all given balls.\n\n\n\n\n\n","category":"function"},{"location":"interface-ball/#Arblib.intersection","page":"Ball methods","title":"Arblib.intersection","text":"intersection(x::ArbOrRef, y::ArbOrRef)\nintersection(x::T, y::T) where {T<:Union{ArbPoly,ArbSeries}}\nintersection(x, y, z...)\n\nintersection(x, y) returns a ball containing the intersection of x and y. If x and y do not overlap (as given by overlaps(a, b)) throws an ArgumentError. For polynomials and series the intersection is taken coefficient-wise.\n\nintersection(x, y, z...) returns a ball containing the intersection of all given balls. If all the balls do not overlap throws an ArgumentError.\n\n\n\n\n\n","category":"function"},{"location":"interface-mutable/#Mutable-arithmetic","page":"Mutable arithmetic","title":"Mutable arithmetic","text":"","category":"section"},{"location":"interface-mutable/","page":"Mutable arithmetic","title":"Mutable arithmetic","text":"The high level interface can be combined with the low level wrapper to allow for efficient computations using mutable arithmetic.","category":"page"},{"location":"interface-mutable/","page":"Mutable arithmetic","title":"Mutable arithmetic","text":"In the future it would be nice to have an interface to MutableArithmetics.jl, see #118.","category":"page"},{"location":"interface-mutable/","page":"Mutable arithmetic","title":"Mutable arithmetic","text":"The following methods are useful for mutating part of a value","category":"page"},{"location":"interface-mutable/","page":"Mutable arithmetic","title":"Mutable arithmetic","text":"Arblib.radref\nArblib.midref\nArblib.realref\nArblib.imagref\nArblib.ref","category":"page"},{"location":"interface-mutable/#Arblib.radref","page":"Mutable arithmetic","title":"Arblib.radref","text":"radref(x::ArbLike, prec = precision(x))\n\nReturn a MagRef referencing the radius of x.\n\n\n\n\n\n","category":"function"},{"location":"interface-mutable/#Arblib.midref","page":"Mutable arithmetic","title":"Arblib.midref","text":"midref(x::ArbLike, prec = precision(x))\n\nReturn an ArfRef referencing the midpoint of x.\n\n\n\n\n\n","category":"function"},{"location":"interface-mutable/#Arblib.realref","page":"Mutable arithmetic","title":"Arblib.realref","text":"realref(z::AcbLike, prec = precision(z))\n\nReturn an ArbRef referencing the real part of x.\n\n\n\n\n\n","category":"function"},{"location":"interface-mutable/#Arblib.imagref","page":"Mutable arithmetic","title":"Arblib.imagref","text":"imagref(z::AcbLike, prec = precision(z))\n\nReturn an ArbRef referencing the imaginary part of x.\n\n\n\n\n\n","category":"function"},{"location":"interface-mutable/#Arblib.ref","page":"Mutable arithmetic","title":"Arblib.ref","text":"ref(v::Union{ArbVectorOrRef,AcbVectorOrRef}, i)\n\nSimilar to v[i] but instead of an Arb or Acb returns an ArbRef or AcbRef which still shares the memory with the i-th entry of v.\n\n\n\n\n\nref(A::Union{ArbMatrixOrRef,AcbMatrixOrRef}, i, j)\n\nSimilar to A[i,j] but instead of an Arb or Acb returns an ArbRef or AcbRef which still shares the memory with the (i,j)-th entry of A.\n\n\n\n\n\nref(p::Union{ArbPoly,ArbSeries,AcbPoly,AcbSeries}, i)\n\nSimilar to p[i] but instead of an Arb or Acb returns an ArbRef or AcbRef which shares the memory with the i-th coefficient of p.\n\nnote: Note\nUsing ref for reading coefficients is always safe, but if the coefficient is mutated then care has to be taken. See the comment further down for how to handle mutation.\n\nIt only allows accessing coefficients that are allocated. For ArbPoly and AcbPoly this is typically all coefficients up to the degree of the polynomial, but can be higher if for example Arblib.fit_length! is used. For ArbSeries and AcbSeries all coefficients up to the degree of the series are guaranteed to be allocated, even if the underlying polynomial has a lower degree.\n\nIf the coefficient is mutated in a way that the degree of the polynomial changes then one needs to also update the internally stored length of the polynomial.\n\nIf the new degree is the same or lower this can be achieved with\nArblib.normalise!(p)\nIf the new degree is higher you need to manually set the length. This can be achieved with\nArblib.set_length!(p, len)\nArblib.normalise!(p)\nwhere len is one higher than (an upper bound of) the new degree.\n\nSee the extended help for more details.\n\nExtended help\n\nHere is an example were the leading coefficient is mutated so that the degree is lowered.\n\njulia> p = ArbPoly([1, 2], prec = 64) # Polynomial of degree 1\n1.0 + 2.0⋅x\n\njulia> Arblib.zero!(Arblib.ref(p, 1)) # Set leading coefficient to 0\n0\n\njulia> Arblib.degree(p) # The degree is still reported as 1\n1\n\njulia> length(p) # And the length as 2\n2\n\njulia> p # Printing gives weird results\n1.0 +\n\njulia> Arblib.normalise!(p) # Normalising the polynomial updates the degree\n1.0\n\njulia> Arblib.degree(p) # This is now correct\n0\n\njulia> p # And so is printing\n1.0\n\nHere is an example when a coefficient above the degree is mutated.\n\njulia> q = ArbSeries([1, 2, 0], prec = 64) # Series of degree 3 with leading coefficient zero\n1.0 + 2.0⋅x + 𝒪(x^3)\n\njulia> Arblib.one!(Arblib.ref(q, 2)) # Set the leading coefficient to 1\n1.0\n\njulia> q # The leading coefficient is not picked up\n1.0 + 2.0⋅x + 𝒪(x^3)\n\njulia> Arblib.degree(q.poly) # The degree of the underlying polynomial is still 1\n1\n\njulia> Arblib.set_length!(q, 3) # After explicitly setting the length to 3 it is ok\n1.0 + 2.0⋅x + 1.0⋅x^2 + 𝒪(x^3)\n\n\n\n\n\n","category":"function"},{"location":"interface-mutable/#Examples","page":"Mutable arithmetic","title":"Examples","text":"","category":"section"},{"location":"interface-mutable/","page":"Mutable arithmetic","title":"Mutable arithmetic","text":"Compare computing sqrtx^2 + y^2 using mutable arithmetic with the default.","category":"page"},{"location":"interface-mutable/","page":"Mutable arithmetic","title":"Mutable arithmetic","text":"using Arblib, BenchmarkTools\n\nx = Arb(1 // 3)\ny = Arb(1 // 5)\nres = zero(x)\n\nf(x, y) = sqrt(x^2 + y^2)\nf!(res, x, y) = begin\n    Arblib.sqr!(res, x)\n    Arblib.fma!(res, res, y, y)\n    return Arblib.sqrt!(res, res)\nend\n\n@benchmark f($x, $y) samples=10000 evals=500\n@benchmark f!($res, $x, $y) samples=10000 evals=500","category":"page"},{"location":"interface-mutable/","page":"Mutable arithmetic","title":"Mutable arithmetic","text":"Set the radius of the real part of an Acb.","category":"page"},{"location":"interface-mutable/","page":"Mutable arithmetic","title":"Mutable arithmetic","text":"using Arblib\n\nz = Acb(1, 2)\nArblib.set!(Arblib.radref(Arblib.realref(z)), 1e-10)\nz","category":"page"},{"location":"interface-mutable/","page":"Mutable arithmetic","title":"Mutable arithmetic","text":"Compare a naive implementation of polynomial evaluation using mutable arithmetic with one not using using it.","category":"page"},{"location":"interface-mutable/","page":"Mutable arithmetic","title":"Mutable arithmetic","text":"using Arblib, BenchmarkTools\n\np = ArbPoly(1:10)\nx = Arb(1 // 3)\nres = zero(x)\n\nfunction eval(p, x)\n    res = zero(x)\n    xi = one(x)\n    for i in 0:Arblib.degree(p)\n        res += p[i] * xi\n        xi *= x\n    end\n    return res\nend\n\nfunction eval!(res, p, x)\n    Arblib.zero!(res)\n    xi = one(x)\n    for i in 0:Arblib.degree(p)\n        Arblib.addmul!(res, Arblib.ref(p, i), xi)\n        Arblib.mul!(xi, xi, x)\n    end\n    return res\nend\n\n@benchmark eval($p, $x) samples = 10000 evals = 30\n@benchmark eval!($res, $p, $x) samples = 10000 evals = 30\n@benchmark $p($x) samples = 10000 evals = 30 # Arb implementation for reference","category":"page"},{"location":"interface-integration/","page":"Integration","title":"Integration","text":"Arblib.integrate\nArblib.integrate!","category":"page"},{"location":"interface-integration/#Arblib.integrate","page":"Integration","title":"Arblib.integrate","text":"integrate(f, a::Number, b::Number;\n    check_analytic::Bool = false,\n    take_prec::Bool = false,\n    prec = max(precision(a), precision(b)),\n    rtol = 0.0,\n    atol = 2.0^-prec,\n    warn_on_no_convergence = true,\n    opts::Union{acb_calc_integrate_opt_struct, Ptr{Cvoid}} = C_NULL)\n\nComputes a rigorous enclosure of the integral ∫ₐᵇ f(x) dx where f(x::AcbRef) is any (holomorphic) julia function. From Arb docs:\n\nThe integral follows a straight-line path between the complex numbers a and b. For finite results, a, b must be finite and f must be bounded on the path of integration. To compute improper integrals, the user should therefore truncate the path of integration manually (or make a regularizing change of variables, if possible).\n\nThe error estimates used require that f is holomorphic on certain ellipses around the path of integration.\n\nThe integration algorithm combines direct interval enclosures, Gauss-Legendre quadrature where f is holomorphic, and adaptive subdivision. This strategy supports integrands with discontinuities while providing exponential convergence for typical piecewise holomorphic integrands.\n\nIn general the integration will work for any function which is holomorpic or meromorphic on the whole complex plane. For functions with branch cuts or other things which makes them non-holomorphic the argument check_analytic has to be set to true. In this case f will be given a keyword argument analytic::Bool, if analytic is false then nothing special has to be done, but if analytic is true then the output has to be non-finite (typically Acb(NaN)) if f is not holomorphic on the whole input ball.\n\nnote: Note\nUsers are responsible for verifying holomorphicity of f.\n\nParameters:\n\ntake_prec if true then f will be given the keyword argument prec = prec, useful for functions requiring an explicit precision to be given.\nrtol relative tolerance\natol absolute tolerance\nwarn_on_no_convergence set this to false to avoid printing a warning in case the integration doesn't converge.\nopts a C_NULL (using the default options), or an instance of acb_calc_integrate_opt_struct controlling the algorithmic aspects of integration.\n\nnote: Note\nintegrate does not guarantee to satisfy provided tolerances. But the integration result is guaranteed to be contained in the returned ball.\n\nFor more information please consider arblib documentation and the paper\n\nFredrik Johansson, Numerical integration in arbitrary-precision ball arithmetic, Mathematical Software – ICMS 2018 https://doi.org/10.1007/978-3-319-96418-8 https://arxiv.org/abs/1802.07942\n\nSee also: integrate!.\n\nExamples\n\njulia> Arblib.integrate(sin, 0, 10) # Integrate sin from 0 to 10\n[1.83907152907645245225886394782406483451993016513316854683595373104879258687 +/- 5.15e-75]\n\njulia> Arblib.integrate(z -> 1/z, Acb(1, -5), Acb(1, 5)) # Integrate 1/z from 1 - 5i to 1 + 5i\n[+/- 2.02e-75] + [2.74680153389003172172254385288992229730199919179940161793956671182574846633 +/- 2.83e-75]im\n\njulia> # Integrate √z from 1 - 5im to 1 + 5im, taking into account the branch cut at (-∞, 0]\n\njulia> f = (z; analytic = false) -> begin\n           if analytic && Arblib.contains_nonpositive(real(z))\n               return Acb(NaN, prec = precision(z))\n           else\n               return sqrt(z)\n           end\n       end;\n\njulia> Arblib.integrate(f, Acb(1, -5), Acb(1, 10), check_analytic = true, prec = 64)\n[-9.0064084416559764 +/- 7.40e-17] + [23.8636067095598007 +/- 9.03e-17]im\n\n\n\n\n\n","category":"function"},{"location":"interface-integration/#Arblib.integrate!","page":"Integration","title":"Arblib.integrate!","text":"integrate!(f!, res::Acb, a::Number, b::Number;\n    check_analytic::Bool = false,\n    take_prec::Bool = false,\n    prec::Integer = precision(res),\n    rtol = 0.0,\n    atol = 2.0^-prec,\n    warn_on_no_convergence = true,\n    opts::Union{acb_calc_integrate_opt_struct, Ptr{Cvoid}} = C_NULL,\n)\n\nLike integrate, but make use of in-place operations. In particular, there are three differences from integrate:\n\nThe function f! should be of the form f!(y, x) = set!(y, f(x)). That is, it writes the return value of the integand f(x) in-place into its first argument y. (The return value of f! is ignored).\nres is set to the result.\nThe default precision is taken from res instead of from a and b.\n\nExamples\n\njulia> Arblib.integrate!(Arblib.sin!, Acb(0), Acb(0), Acb(10)) # Integrate sin from 0 to 10\n[1.83907152907645245225886394782406483451993016513316854683595373104879258687 +/- 5.15e-75]\n\njulia> Arblib.integrate!(Arblib.inv!, Acb(0), Acb(1, -5), Acb(1, 5)) # Integrate 1/z from 1 - 5i to 1 + 5i\n[+/- 2.02e-75] + [2.74680153389003172172254385288992229730199919179940161793956671182574846633 +/- 2.83e-75]im\n\njulia> # Integrate √z from 1 - 5im to 1 + 5im, taking into account the branch cut at (-∞, 0]\n\njulia> f! = (res, z; analytic = false) -> Arblib.sqrt_analytic!(res, z, analytic);\n\njulia> Arblib.integrate!(f!, Acb(0), Acb(1, -5), Acb(1, 10), check_analytic = true, prec = 64)\n[-9.0064084416559764 +/- 6.53e-17] + [23.8636067095598007 +/- 6.98e-17]im\n\n\n\n\n\n","category":"function"},{"location":"interface-types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"interface-types/","page":"Types","title":"Types","text":"The package defines a number of types for the high level interface.","category":"page"},{"location":"interface-types/#Basic","page":"Types","title":"Basic","text":"","category":"section"},{"location":"interface-types/","page":"Types","title":"Types","text":"These types directly map to corresponding Arb types.","category":"page"},{"location":"interface-types/","page":"Types","title":"Types","text":"Mag\nArf\nArb\nAcb\nArbVector\nAcbVector\nArbPoly\nAcbPoly\nArbMatrix\nAcbMatrix","category":"page"},{"location":"interface-types/#Arblib.Mag","page":"Types","title":"Arblib.Mag","text":"Mag <: Real\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Arblib.Arf","page":"Types","title":"Arblib.Arf","text":"Arf <: AbstractFloat\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Arblib.Arb","page":"Types","title":"Arblib.Arb","text":"Arb <: AbstractFloat\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Arblib.Acb","page":"Types","title":"Arblib.Acb","text":"Acb <: Number\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Arblib.ArbVector","page":"Types","title":"Arblib.ArbVector","text":"ArbVector <: DenseVector{Arb}\nArbVector(n::Integer; prec::Integer = DEFAULT_PRECISION[])\nArbVector(v::ArbVectorLike; shallow::Bool = false, prec::Integer = precision(v))\nArbVector(v::AbstractVector; prec::Integer = _precision(v))\n\nThe constructor with n::Integer returns a vector with n elements filled with zeros. The other two constructors returns a copy of the given vector. If shallow = true then the returned vector shares the underlying data with the input, mutating one of them mutates both.\n\nSee also ArbRefVector.\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Arblib.AcbVector","page":"Types","title":"Arblib.AcbVector","text":"AcbVector <: DenseVector{Acb}\nAcbVector(n::Integer; prec::Integer = DEFAULT_PRECISION[])\nAcbVector(v::AcbVectorLike; shallow::Bool = false, prec::Integer = precision(v))\nAcbVector(v::AbstractVector; prec::Integer = _precision(v))\n\nThe constructor with n::Integer returns a vector with n elements filled with zeros. The other two constructors returns a copy of the given vector. If shallow = true then the returned vector shares the underlying data with the input, mutating one of them mutates both.\n\nSee also AcbRefVector.\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Arblib.ArbPoly","page":"Types","title":"Arblib.ArbPoly","text":"ArbPoly\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Arblib.AcbPoly","page":"Types","title":"Arblib.AcbPoly","text":"AcbPoly\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Arblib.ArbMatrix","page":"Types","title":"Arblib.ArbMatrix","text":"ArbMatrix <: DenseMatrix{Arb}\nArbMatrix(r::Integer, c::Integer; prec::Integer = DEFAULT_PRECISION[])\nArbMatrix(A::ArbMatrixLike; shallow::Bool = false, prec::Integer = precision(v))\nArbMatrix(A::AbstractMatrix; prec::Integer = _precision(v))\nArbMatrix(v::AbstractVector; prec::Integer = _precision(v))\n\nThe constructor with r::Integer, c::Integer returns a r × c filled with zeros. The other three constructors returns a copy of the given matrix or vector. If shallow = true then the returned matrix shares the underlying data with the input, mutating one of them mutates both.\n\nSee also ArbRefMatrix.\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Arblib.AcbMatrix","page":"Types","title":"Arblib.AcbMatrix","text":"AcbMatrix <: DenseMatrix{Acb}\nAcbMatrix(r::Integer, c::Integer; prec::Integer = DEFAULT_PRECISION[])\nAcbMatrix(A::AcbMatrixLike; shallow::Bool = false, prec::Integer = precision(v))\nAcbMatrix(A::AbstractMatrix; prec::Integer = _precision(v))\nAcbMatrix(v::AbstractVector; prec::Integer = _precision(v))\n\nThe constructor with r::Integer, c::Integer returns a r × c filled with zeros. The other three constructors returns a copy of the given matrix or vector. If shallow = true then the returned matrix shares the underlying data with the input, mutating one of them mutates both.\n\nSee also AcbRefMatrix.\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Series","page":"Types","title":"Series","text":"","category":"section"},{"location":"interface-types/","page":"Types","title":"Types","text":"The package defines two series types, which are wrapper for the polynomial types with a specified degree.","category":"page"},{"location":"interface-types/","page":"Types","title":"Types","text":"ArbSeries\nAcbSeries","category":"page"},{"location":"interface-types/#Arblib.ArbSeries","page":"Types","title":"Arblib.ArbSeries","text":"ArbSeries <: Number\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Arblib.AcbSeries","page":"Types","title":"Arblib.AcbSeries","text":"AcbSeries <: Number\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Ref","page":"Types","title":"Ref","text":"","category":"section"},{"location":"interface-types/","page":"Types","title":"Types","text":"In addition to these there are a number of Ref types, which allow for non-allocating access in a number of cases.","category":"page"},{"location":"interface-types/","page":"Types","title":"Types","text":"MagRef\nArfRef\nArbRef\nAcbRef\nArbRefVector\nAcbRefVector\nArbRefMatrix\nAcbRefMatrix","category":"page"},{"location":"interface-types/#Arblib.MagRef","page":"Types","title":"Arblib.MagRef","text":"MagRef <: Real\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Arblib.ArfRef","page":"Types","title":"Arblib.ArfRef","text":"ArfRef <: AbstractFloat\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Arblib.ArbRef","page":"Types","title":"Arblib.ArbRef","text":"ArbRef <: AbstractFloat\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Arblib.AcbRef","page":"Types","title":"Arblib.AcbRef","text":"AcbRef <: Number\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Arblib.ArbRefVector","page":"Types","title":"Arblib.ArbRefVector","text":"ArbRefVector <: DenseMatrix{ArbRef}\n\nSimilar to ArbVector but indexing elements returns an ArbRef referencing the corresponding element instead of an Arb copy of the element. The constructors are the same as for ArbVector\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Arblib.AcbRefVector","page":"Types","title":"Arblib.AcbRefVector","text":"AcbRefVector <: DenseMatrix{AcbRef}\n\nSimilar to AcbVector but indexing elements returns an AcbRef referencing the corresponding element instead of an Acb copy of the element. The constructors are the same as for AcbVector\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Arblib.ArbRefMatrix","page":"Types","title":"Arblib.ArbRefMatrix","text":"ArbRefMatrix <: DenseMatrix{ArbRef}\n\nSimilar to ArbMatrix but indexing elements returns an ArbRef referencing the corresponding element instead of an Arb copy of the element. The constructors are the same as for ArbMatrix\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Arblib.AcbRefMatrix","page":"Types","title":"Arblib.AcbRefMatrix","text":"AcbRefMatrix <: DenseMatrix{AcbRef}\n\nSimilar to AcbMatrix but indexing elements returns an AcbRef referencing the corresponding element instead of an Acb copy of the element. The constructors are the same as for `AcbMatrix\n\n\n\n\n\n","category":"type"},{"location":"interface-types/#Correspondence-between-types","page":"Types","title":"Correspondence between types","text":"","category":"section"},{"location":"interface-types/","page":"Types","title":"Types","text":"We have the following table for the correspondence with between the Low level wrapper types and the high level interface types.","category":"page"},{"location":"interface-types/","page":"Types","title":"Types","text":"Arb Wrapper High level Ref\nmag_t mag_struct Mag MagRef\narf_t arf_struct Arf ArfRef\narb_t arb_struct Arb ArbRef\nacb_t acb_struct Acb AcbRef\narb_t* arb_vec_struct ArbVector ArbRefVector\nacb_t* acb_vec_struct AcbVector AcbRefVector\narb_poly_t arb_poly_struct ArbPoly or ArbSeries \nacb_poly_t acb_poly_struct AcbPoly or AcbSeries \narb_mat_t arb_mat_struct ArbMatrix ArbRefMatrix\nacb_mat_t acb_mat_struct AcbMatrix AcbRefMatrix","category":"page"},{"location":"wrapper-methods/#Methods","page":"Methods","title":"Methods","text":"","category":"section"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"The methods for the low level wrapper are automatically generated by parsing the Arb documentation. This is handled by the Arblib.ArbCall module.","category":"page"},{"location":"wrapper-methods/#Parsing","page":"Methods","title":"Parsing","text":"","category":"section"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"The parsing is handled by","category":"page"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"Arblib.ArbCall.parse_and_generate_arbdoc","category":"page"},{"location":"wrapper-methods/#Arblib.ArbCall.parse_and_generate_arbdoc","page":"Methods","title":"Arblib.ArbCall.parse_and_generate_arbdoc","text":"parse_and_generate_arbdoc(doc_dir, out_dir = \"src/arbcalls/\"; filenames, verbose)\n\nParses the Flint documentation and generates corresponding Julia files. The value of doc_dir should be a path to the directory doc/source/ in the Flint directory.\n\nThe filenames argument can be given to specify specific doc files to use. The verbose argument can be set to true to give more information about the result of the parsing.\n\n\n\n\n\n","category":"function"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"Note that the parsing is done ahead of time and the generated files in src/arbcalls/ are added to git. As a user of the package you therefore typically don't need to care about this step.","category":"page"},{"location":"wrapper-methods/#Generated-methods","page":"Methods","title":"Generated methods","text":"","category":"section"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"The automatic generation of the methods is handled by","category":"page"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"Arblib.ArbCall.@arbcall_str\nArblib.ArbCall.ArbFunction\nArblib.ArbCall.jlcode(af::Arblib.ArbCall.ArbFunction)","category":"page"},{"location":"wrapper-methods/#Arblib.ArbCall.@arbcall_str","page":"Methods","title":"Arblib.ArbCall.@arbcall_str","text":"@arbcall_str str\n\nParse a string as an Arblib.ArbCall.ArbFunction, generate the code for a corresponding method with Arblib.ArbCall.jlcode and evaluate the code.\n\nFor example\n\narbcall\"void arb_zero(arb_t x)\"\n\ndefines the method zero!(x::ArbLike).\n\n\n\n\n\n","category":"macro"},{"location":"wrapper-methods/#Arblib.ArbCall.ArbFunction","page":"Methods","title":"Arblib.ArbCall.ArbFunction","text":"ArbFunction{T}(fname::String, args::Vector{Carg})\n\nStruct representing a C-function in the Arb library.\n\n\n\n\n\n","category":"type"},{"location":"wrapper-methods/#Arblib.ArbCall.jlcode-Tuple{Arblib.ArbCall.ArbFunction}","page":"Methods","title":"Arblib.ArbCall.jlcode","text":"jlcode(af::ArbFunction, jl_fname = jlfname(af))\n\nGenerate the Julia code for calling the Arb function from Julia.\n\n\n\n\n\n","category":"method"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"The main things to understand is how the name of the generated function is determined, how the arguments are handled and the return value.","category":"page"},{"location":"wrapper-methods/#Naming","page":"Methods","title":"Naming","text":"","category":"section"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"The name of the Arb function is \"Juliafied\" using the following guidelines:","category":"page"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"Prefixes and suffixes a function name which only refer to the type of input are removed since Julia has multiple dispatch to deal with this problem.\nFunctions which modify the first argument get an ! appended to the name.","category":"page"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"The implementation is based on heuristics for determining when part of the function name is referring to the type or when the function modifies the argument. This works well for the majority of functions but gives a few odd cases.","category":"page"},{"location":"wrapper-methods/#Arguments","page":"Methods","title":"Arguments","text":"","category":"section"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"The arguments of the function are represented by","category":"page"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"Arblib.ArbCall.Carg","category":"page"},{"location":"wrapper-methods/#Arblib.ArbCall.Carg","page":"Methods","title":"Arblib.ArbCall.Carg","text":"Carg{T}(name, isconst)\nCarg(str::AbstractString)\n\nStruct representing a argument to a C function in the Arb library. The corresponding Julia type is T, name is the name of the argument, isconst is true if the argument is declared as a const.\n\njulia> Arblib.ArbCall.Carg(\"const arb_t x\")\nArblib.ArbCall.Carg{Arb}(:x, true)\n\n\n\n\n\n","category":"type"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"For the generated method the allowed types for the argument is determined by","category":"page"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"Arblib.ArbCall.jltype\nArblib.ArbCall.ctype","category":"page"},{"location":"wrapper-methods/#Arblib.ArbCall.jltype","page":"Methods","title":"Arblib.ArbCall.jltype","text":"jltype(ca::Carg{T})\n\nThe most general Julia type for which we allow automatic conversion to the Arblib.ArbCall.ctype of ca.\n\nThese conversations should be done without any loss of information, for example for floating point numbers we only allow conversion from types with lower precision. In general the conversion is done using Base.cconvert.\n\n\n\n\n\n","category":"function"},{"location":"wrapper-methods/#Arblib.ArbCall.ctype","page":"Methods","title":"Arblib.ArbCall.ctype","text":"ctype(ca::Carg)\n\nThe type that should be used for the argument when passed to C code.\n\n\n\n\n\n","category":"function"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"Some arguments are automatically converted to keyword arguments.","category":"page"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"For functions which take a precision argument this argument becomes a prec::Integer keyword argument which is by default set to the precision of the first argument (if applicable).\nFor functions which take a rounding mode argument this argument becomes a rnd::Union{Arblib.arb_rnd,RoundingMode} keyword argument which is by default set to RoundNearest.\nFor functions which takes a flag argument this argument becomes a flag::Integer keyword argument which is by default set to 0.\nFor functions which takes an argument giving the length of the vector preceding the argument this argument becomes a keyword argument which is by default set to the length of the preceding vector. In this case the name of the keyword argument is the same as the argument name in the function declaration.","category":"page"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"As with the naming the implementation is based on heuristics for determining when an argument is supposed to be a certain kind of keyword argument.","category":"page"},{"location":"wrapper-methods/#Return-value","page":"Methods","title":"Return value","text":"","category":"section"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"The returned value is determined in the following way","category":"page"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"For functions which have the C function has return type void and modify the first argument the generated method returns the first argument. This is follows the normal convention in Julia.\nFor predicates, for which the C function returns int, the return value is converted to a Bool.\nOtherwise the return type is the same as for the C function.","category":"page"},{"location":"wrapper-methods/#Examples","page":"Methods","title":"Examples","text":"","category":"section"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"For example Arb declares the following functions","category":"page"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"void arb_zero(arb_t x)\nslong arb_rel_error_bits(const arb_t x)\nint arb_is_zero(const arb_t x)\nvoid arb_add(arb_t z, const arb_t x, const arb_t y, slong prec)\nvoid arb_add_arf(arb_t z, const arb_t x, const arf_t y, slong prec)\nvoid arb_add_ui(arb_t z, const arb_t x, ulong y, slong prec)\nvoid arb_add_si(arb_t z, const arb_t x, slong y, slong prec)\nvoid arb_sin(arb_t s, const arb_t x, slong prec)\nvoid arb_cos(arb_t c, const arb_t x, slong prec)\nvoid arb_sin_cos(arb_t s, arb_t c, const arb_t x, slong prec)\nint arf_add(arf_t res, const arf_t x, const arf_t y, slong prec, arf_rnd_t rnd)","category":"page"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"For which the following methods are generated","category":"page"},{"location":"wrapper-methods/","page":"Methods","title":"Methods","text":"zero!(x::ArbLike)::ArbLike\nrel_error_bits(x::ArbLike)::Int\nis_zero(x::ArbLike)::Bool\nadd!(z::ArbLike, x::ArbLike, y::ArbLike; prec::Integer = _precision(z))::ArbLike\nadd!(z::ArbLike, x::ArbLike, y::ArfLike; prec::Integer = _precision(z))::ArbLike\nadd!(z::ArbLike, x::ArbLike, y::Unsigned; prec::Integer = _precision(z))::ArbLike\nadd!(z::ArbLike, x::ArbLike, y::Integer; prec::Integer = _precision(z))::ArbLike\nsin!(s::ArbLike, x::ArbLike; prec::Integer = _precision(s))::ArbLike\ncos!(c::ArbLike, x::ArbLike; prec::Integer = _precision(c))::ArbLike\nsin_cos!(s::ArbLike, c::ArbLike, x::ArbLike, prec::Integer = _precision(s))::ArbLike\nadd!(res::ArfLike, x::ArfLike, y::ArfLike; prec::Integer = _precision(res), rnd::Union{Arblib.arb_rnd, RoundingMode} = RoundNearest)::Int32","category":"page"},{"location":"#Arblib.jl-Documentation","page":"Arblib.jl Documentation","title":"Arblib.jl Documentation","text":"","category":"section"},{"location":"","page":"Arblib.jl Documentation","title":"Arblib.jl Documentation","text":"This package is a wrapper around Arb - a C library for arbitrary-precision ball arithmetic. Since 2023 Arb is part of Flint. Other wrappers of Arb/Flint for Julia include Nemo and ArbNumerics.jl.","category":"page"},{"location":"","page":"Arblib.jl Documentation","title":"Arblib.jl Documentation","text":"The goal of Arblib.jl is to supply a low lever wrapper of the methods in Arb as well as a high level interface. The low level wrapper should allow for writing methods using mutability and with performance very close to that of those written in C. The high level interface should make it easy to use in generic Julia code, similarly to how BigFloat is a wrapper around the MPFR library. In addition it should be possible to seamlessly switch between the high level interface and the low level wrapper when needed.","category":"page"},{"location":"","page":"Arblib.jl Documentation","title":"Arblib.jl Documentation","text":"The above goals can be put into contrast with Nemo, whose high level interface is made for use in the AbstractAlgebra.jl universe and not general Julia code.","category":"page"},{"location":"wrapper-types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"wrapper-types/","page":"Types","title":"Types","text":"The package defines the following types which map directly to Arb types with the corresponding name. In most cases you should not use these types directly but use the types from the High level interface.","category":"page"},{"location":"wrapper-types/","page":"Types","title":"Types","text":"Arblib.mag_struct\nArblib.arf_struct\nArblib.arb_struct\nArblib.acb_struct\nArblib.arb_vec_struct\nArblib.acb_vec_struct\nArblib.arb_poly_struct\nArblib.acb_poly_struct\nArblib.arb_mat_struct\nArblib.acb_mat_struct\nArblib.calc_integrate_opt_struct","category":"page"},{"location":"wrapper-types/#Arblib.mag_struct","page":"Types","title":"Arblib.mag_struct","text":"mag_struct\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.arf_struct","page":"Types","title":"Arblib.arf_struct","text":"arf_struct\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.arb_struct","page":"Types","title":"Arblib.arb_struct","text":"arb_struct\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.acb_struct","page":"Types","title":"Arblib.acb_struct","text":"acb_struct\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.arb_vec_struct","page":"Types","title":"Arblib.arb_vec_struct","text":"arb_vec_struct\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.acb_vec_struct","page":"Types","title":"Arblib.acb_vec_struct","text":"acb_vec_struct\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.arb_poly_struct","page":"Types","title":"Arblib.arb_poly_struct","text":"arb_poly_struct\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.acb_poly_struct","page":"Types","title":"Arblib.acb_poly_struct","text":"acb_poly_struct\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.arb_mat_struct","page":"Types","title":"Arblib.arb_mat_struct","text":"arb_mat_struct\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.acb_mat_struct","page":"Types","title":"Arblib.acb_mat_struct","text":"acb_mat_struct\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.calc_integrate_opt_struct","page":"Types","title":"Arblib.calc_integrate_opt_struct","text":"calc_integrate_opt_struct\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/","page":"Types","title":"Types","text":"For each low-level type there is a union of types that can be interpreted as the low-level type. These are the types that can be given directly as arguments to the low-level methods. Below you find these union-types.","category":"page"},{"location":"wrapper-types/","page":"Types","title":"Types","text":"Arblib.MagLike\nArblib.ArfLike\nArblib.ArbLike\nArblib.AcbLike\nArblib.ArbVectorLike\nArblib.AcbVectorLike\nArblib.ArbMatrixLike\nArblib.AcbMatrixLike\nArblib.ArbPolyLike\nArblib.AcbPolyLike","category":"page"},{"location":"wrapper-types/#Arblib.MagLike","page":"Types","title":"Arblib.MagLike","text":"MagLike = Union{Mag,MagRef,mag_struct,Ptr{mag_struct}}\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.ArfLike","page":"Types","title":"Arblib.ArfLike","text":"ArfLike = Union{Arf,ArfRef,arf_struct,Ptr{arf_struct}}}\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.ArbLike","page":"Types","title":"Arblib.ArbLike","text":"ArbLike = Union{Arb,ArbRef,arb_struct,Ptr{arb_struct}}}\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.AcbLike","page":"Types","title":"Arblib.AcbLike","text":"AcbLike = Union{Acb,AcbRef,acb_struct,Ptr{acb_struct}}}\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.ArbVectorLike","page":"Types","title":"Arblib.ArbVectorLike","text":"ArbVectorLike = Union{ArbVector,ArbRefVector,arb_vec_struct}\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.AcbVectorLike","page":"Types","title":"Arblib.AcbVectorLike","text":"AcbVectorLike = Union{AcbVector,AcbRefVector,acb_vec_struct}\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.ArbMatrixLike","page":"Types","title":"Arblib.ArbMatrixLike","text":"ArbMatrixLike = Union{ArbMatrix,ArbRefMatrix,arb_mat_struct)}\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.AcbMatrixLike","page":"Types","title":"Arblib.AcbMatrixLike","text":"AcbMatrixLike = Union{AcbMatrix,AcbRefMatrix,acb_mat_struct}\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.ArbPolyLike","page":"Types","title":"Arblib.ArbPolyLike","text":"ArbPolyLike = Union{ArbPoly,ArbSeries,arb_poly_struct}\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/#Arblib.AcbPolyLike","page":"Types","title":"Arblib.AcbPolyLike","text":"AcbPolyLike = Union{AcbPoly,AcbSeries,acb_poly_struct}\n\n\n\n\n\n","category":"type"},{"location":"wrapper-types/","page":"Types","title":"Types","text":"Note that the show method is overloaded for these union types, this is to make method declarations easier to read in the REPL. As an example we can print the methods for Arblib.sin! and we see that it prints ArbLike instead of the much longer Union{Ptr{Arblib.arb_struct}, Arb, ArbRef, Arblib.arb_struct}.","category":"page"},{"location":"wrapper-types/","page":"Types","title":"Types","text":"using Arblib\n\nmethods(Arblib.sin!)","category":"page"}]
}
