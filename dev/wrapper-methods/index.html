<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · Arblib.jl</title><meta name="title" content="Methods · Arblib.jl"/><meta property="og:title" content="Methods · Arblib.jl"/><meta property="twitter:title" content="Methods · Arblib.jl"/><meta name="description" content="Documentation for Arblib.jl."/><meta property="og:description" content="Documentation for Arblib.jl."/><meta property="twitter:description" content="Documentation for Arblib.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Arblib.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Arblib.jl Documentation</a></li><li><span class="tocitem">Low level wrapper</span><ul><li><a class="tocitem" href="../wrapper-types/">Types</a></li><li class="is-active"><a class="tocitem" href>Methods</a><ul class="internal"><li><a class="tocitem" href="#Parsing"><span>Parsing</span></a></li><li><a class="tocitem" href="#Generated-methods"><span>Generated methods</span></a></li></ul></li><li><a class="tocitem" href="../wrapper-fpwrap/">Floating point wrapper</a></li></ul></li><li><span class="tocitem">High level interface</span><ul><li><a class="tocitem" href="../interface-types/">Types</a></li><li><a class="tocitem" href="../interface-ball/">Ball methods</a></li><li><a class="tocitem" href="../interface-integration/">Integration</a></li><li><a class="tocitem" href="../interface-series/">Series</a></li><li><a class="tocitem" href="../interface-mutable/">Mutable arithmetic</a></li></ul></li><li><a class="tocitem" href="../rigorous/">Rigorous numerics</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Low level wrapper</a></li><li class="is-active"><a href>Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kalmarek/Arblib.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/kalmarek/Arblib.jl/blob/master/docs/src/wrapper-methods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h1><p>The methods for the low level wrapper are automatically generated by parsing the Arb documentation. This is handled by the <code>Arblib.ArbCall</code> module.</p><h2 id="Parsing"><a class="docs-heading-anchor" href="#Parsing">Parsing</a><a id="Parsing-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing" title="Permalink"></a></h2><p>The parsing is handled by</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arblib.ArbCall.parse_and_generate_arbdoc" href="#Arblib.ArbCall.parse_and_generate_arbdoc"><code>Arblib.ArbCall.parse_and_generate_arbdoc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parse_and_generate_arbdoc(doc_dir, out_dir = &quot;src/arbcalls/&quot;; filenames, verbose)</code></pre><p>Parses the Flint documentation and generates corresponding Julia files. The value of <code>doc_dir</code> should be a path to the directory <code>doc/source/</code> in the Flint directory.</p><p>The <code>filenames</code> argument can be given to specify specific doc files to use. The <code>verbose</code> argument can be set to true to give more information about the result of the parsing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/Arblib.jl/blob/9219b51f2c4387acc683682313f7d835ad631129/src/ArbCall/parse.jl#L179-L189">source</a></section></article><p>Note that the parsing is done ahead of time and the generated files in <code>src/arbcalls/</code> are added to git. As a user of the package you therefore typically don&#39;t need to care about this step.</p><h2 id="Generated-methods"><a class="docs-heading-anchor" href="#Generated-methods">Generated methods</a><a id="Generated-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Generated-methods" title="Permalink"></a></h2><p>The automatic generation of the methods is handled by</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arblib.ArbCall.@arbcall_str" href="#Arblib.ArbCall.@arbcall_str"><code>Arblib.ArbCall.@arbcall_str</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@arbcall_str str</code></pre><p>Parse a string as an <a href="#Arblib.ArbCall.ArbFunction"><code>Arblib.ArbCall.ArbFunction</code></a>, generate the code for a corresponding method with <a href="../wrapper-fpwrap/#Arblib.ArbCall.jlcode-Tuple{Arblib.ArbCall.ArbFPWrapFunction}"><code>Arblib.ArbCall.jlcode</code></a> and evaluate the code.</p><p>For example</p><pre><code class="nohighlight hljs">arbcall&quot;void arb_zero(arb_t x)&quot;</code></pre><p>defines the method <code>zero!(x::ArbLike)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/Arblib.jl/blob/9219b51f2c4387acc683682313f7d835ad631129/src/ArbCall/ArbFunction.jl#L252-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arblib.ArbCall.ArbFunction" href="#Arblib.ArbCall.ArbFunction"><code>Arblib.ArbCall.ArbFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ArbFunction{T}(fname::String, args::Vector{Carg})</code></pre><p>Struct representing a C-function in the Arb library.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/Arblib.jl/blob/9219b51f2c4387acc683682313f7d835ad631129/src/ArbCall/ArbFunction.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arblib.ArbCall.jlcode-Tuple{Arblib.ArbCall.ArbFunction}" href="#Arblib.ArbCall.jlcode-Tuple{Arblib.ArbCall.ArbFunction}"><code>Arblib.ArbCall.jlcode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jlcode(af::ArbFunction, jl_fname = jlfname(af))</code></pre><p>Generate the Julia code for calling the Arb function from Julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/Arblib.jl/blob/9219b51f2c4387acc683682313f7d835ad631129/src/ArbCall/ArbFunction.jl#L191-L195">source</a></section></article><p>The main things to understand is how the name of the generated function is determined, how the arguments are handled and the return value.</p><h3 id="Naming"><a class="docs-heading-anchor" href="#Naming">Naming</a><a id="Naming-1"></a><a class="docs-heading-anchor-permalink" href="#Naming" title="Permalink"></a></h3><p>The name of the Arb function is &quot;Juliafied&quot; using the following guidelines:</p><ol><li>Prefixes and suffixes a function name which only refer to the type of input are removed since Julia has multiple dispatch to deal with this problem.</li><li>Functions which modify the first argument get an <code>!</code> appended to the name.</li></ol><p>The implementation is based on heuristics for determining when part of the function name is referring to the type or when the function modifies the argument. This works well for the majority of functions but gives a few odd cases.</p><h3 id="Arguments"><a class="docs-heading-anchor" href="#Arguments">Arguments</a><a id="Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Arguments" title="Permalink"></a></h3><p>The arguments of the function are represented by</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arblib.ArbCall.Carg" href="#Arblib.ArbCall.Carg"><code>Arblib.ArbCall.Carg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Carg{T}(name, isconst)
Carg(str::AbstractString)</code></pre><p>Struct representing a argument to a C function in the Arb library. The corresponding Julia type is <code>T</code>, <code>name</code> is the name of the argument, <code>isconst</code> is true if the argument is declared as a const.</p><pre><code class="language-julia-repl hljs">julia&gt; Arblib.ArbCall.Carg(&quot;const arb_t x&quot;)
Arblib.ArbCall.Carg{Arb}(:x, true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/Arblib.jl/blob/9219b51f2c4387acc683682313f7d835ad631129/src/ArbCall/Carg.jl#L1-L13">source</a></section></article><p>For the generated method the allowed types for the argument is determined by</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arblib.ArbCall.jltype" href="#Arblib.ArbCall.jltype"><code>Arblib.ArbCall.jltype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jltype(ca::Carg{T})</code></pre><p>The most general Julia type for which we allow automatic conversion to the <a href="#Arblib.ArbCall.ctype"><code>Arblib.ArbCall.ctype</code></a> of <code>ca</code>.</p><p>These conversations should be done without any loss of information, for example for floating point numbers we only allow conversion from types with lower precision. In general the conversion is done using <code>Base.cconvert</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/Arblib.jl/blob/9219b51f2c4387acc683682313f7d835ad631129/src/ArbCall/Carg.jl#L47-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Arblib.ArbCall.ctype" href="#Arblib.ArbCall.ctype"><code>Arblib.ArbCall.ctype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ctype(ca::Carg)</code></pre><p>The type that should be used for the argument when passed to C code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kalmarek/Arblib.jl/blob/9219b51f2c4387acc683682313f7d835ad631129/src/ArbCall/Carg.jl#L83-L87">source</a></section></article><p>Some arguments are automatically converted to keyword arguments.</p><ol><li>For functions which take a precision argument this argument becomes a <code>prec::Integer</code> keyword argument which is by default set to the precision of the first argument (if applicable).</li><li>For functions which take a rounding mode argument this argument becomes a <code>rnd::Union{Arblib.arb_rnd,RoundingMode}</code> keyword argument which is by default set to <code>RoundNearest</code>.</li><li>For functions which takes a flag argument this argument becomes a <code>flag::Integer</code> keyword argument which is by default set to <code>0</code>.</li><li>For functions which takes an argument giving the length of the vector preceding the argument this argument becomes a keyword argument which is by default set to the length of the preceding vector. In this case the name of the keyword argument is the same as the argument name in the function declaration.</li></ol><p>As with the naming the implementation is based on heuristics for determining when an argument is supposed to be a certain kind of keyword argument.</p><h3 id="Return-value"><a class="docs-heading-anchor" href="#Return-value">Return value</a><a id="Return-value-1"></a><a class="docs-heading-anchor-permalink" href="#Return-value" title="Permalink"></a></h3><p>The returned value is determined in the following way</p><ol><li>For functions which have the C function has return type <code>void</code> and modify the first argument the generated method returns the first argument. This is follows the normal convention in Julia.</li><li>For predicates, for which the C function returns <code>int</code>, the return value is converted to a <code>Bool</code>.</li><li>Otherwise the return type is the same as for the C function.</li></ol><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><p>For example Arb declares the following functions</p><ol><li><code>void arb_zero(arb_t x)</code></li><li><code>slong arb_rel_error_bits(const arb_t x)</code></li><li><code>int arb_is_zero(const arb_t x)</code></li><li><code>void arb_add(arb_t z, const arb_t x, const arb_t y, slong prec)</code></li><li><code>void arb_add_arf(arb_t z, const arb_t x, const arf_t y, slong prec)</code></li><li><code>void arb_add_ui(arb_t z, const arb_t x, ulong y, slong prec)</code></li><li><code>void arb_add_si(arb_t z, const arb_t x, slong y, slong prec)</code></li><li><code>void arb_sin(arb_t s, const arb_t x, slong prec)</code></li><li><code>void arb_cos(arb_t c, const arb_t x, slong prec)</code></li><li><code>void arb_sin_cos(arb_t s, arb_t c, const arb_t x, slong prec)</code></li><li><code>int arf_add(arf_t res, const arf_t x, const arf_t y, slong prec, arf_rnd_t rnd)</code></li><li><code>void arb_poly_sin_series(arb_poly_t s, const arb_poly_t h, slong n, slong prec)</code></li></ol><p>For which the following methods are generated</p><ol><li><code>zero!(x::ArbLike)::ArbLike</code></li><li><code>rel_error_bits(x::ArbLike)::Int</code></li><li><code>is_zero(x::ArbLike)::Bool</code></li><li><code>add!(z::ArbLike, x::ArbLike, y::ArbLike; prec::Integer = _precision(z))::ArbLike</code></li><li><code>add!(z::ArbLike, x::ArbLike, y::ArfLike; prec::Integer = _precision(z))::ArbLike</code></li><li><code>add!(z::ArbLike, x::ArbLike, y::Unsigned; prec::Integer = _precision(z))::ArbLike</code></li><li><code>add!(z::ArbLike, x::ArbLike, y::Integer; prec::Integer = _precision(z))::ArbLike</code></li><li><code>sin!(s::ArbLike, x::ArbLike; prec::Integer = _precision(s))::ArbLike</code></li><li><code>cos!(c::ArbLike, x::ArbLike; prec::Integer = _precision(c))::ArbLike</code></li><li><code>sin_cos!(s::ArbLike, c::ArbLike, x::ArbLike, prec::Integer = _precision(s))::ArbLike</code></li><li><code>add!(res::ArfLike, x::ArfLike, y::ArfLike; prec::Integer = _precision(res), rnd::Union{Arblib.arb_rnd, RoundingMode} = RoundNearest)::Int32</code></li><li><code>sin_series!(s::ArbPolyLike, h::ArbPolyLike, n::Integer; prec::Integer = _precision(s))::ArbPolyLike</code></li></ol><h3 id="Series-methods"><a class="docs-heading-anchor" href="#Series-methods">Series methods</a><a id="Series-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Series-methods" title="Permalink"></a></h3><p>Arb has several functions mean for computing truncated Taylor series (e.g. <code>arb_sin_series</code>). These functions have special handling, to make them more convenient to use. In addition to the procedure discussed above they generate one more method. This extra method removes the &quot;_series&quot; suffix from the method name, restricts the input type to only series types (and not polynomial types) and takes the default length of the computed series from the first argument. As an example the function</p><ul><li><code>void arb_poly_sin_series(arb_poly_t s, const arb_poly_t h, slong n, slong prec)</code></li></ul><p>generates the method</p><ul><li><code>sin!(s::ArbSeries, h::ArbSeries, n::Integer = length(s); prec::Integer = _precision(s))::ArbSeries</code></li></ul><p>in addition to the usual one (see the examples above).</p><p>The main motivation for these extra methods is to make it easier to write generic code using mutability, see <a href="../interface-mutable/#Mutable-arithmetic">Mutable arithmetic</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../wrapper-types/">« Types</a><a class="docs-footer-nextpage" href="../wrapper-fpwrap/">Floating point wrapper »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Thursday 20 March 2025 14:57">Thursday 20 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
